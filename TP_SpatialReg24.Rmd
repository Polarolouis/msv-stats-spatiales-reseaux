---
title: "Autocorrélation et Régression spatiale"
author: "Données discrètes"
date: "2024-02-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# TP Autocorrélation et Régression spatiale : 

## Objectif

Les espèces épibenthiques (qui vivent sur les fonds marins) sont des  biomarqueurs de l'état environnemental et des sources d'alimentation des poissons de la baie du Saint Laurent. Depuis plusieurs années des campagnes scientifiques sont menées pour mesurer la biomasse de ces espèces.
Le Golfe du Saint Laurent est découpé en strates de milieux homogènes.   
Le fichier StLaurent.csv contient pour l'année 2000 les valeurs des variables suivantes :

|strate  | numéro de la strate|
|:-------|:---------------------|
|longitude | longitude du centre de la strate|
|latitude | latitude du centre de la strate|
|BH | présence (1) absence (0) de bernard l'hermite|
|totconsum |indice de prédation|
|depth | profondeur|
|temperature |température|

Le fichier *bornes.txt* donne pour les 38 strates les coordonnées des points formant les bords:

|colonne 1 | numéro de la strate  (de 401 à 438)|
|:---------|:---------------------------------------|
|colonne 2 | longitude du point|
|colonne 3 | latitude du point|



## Chargement des packages
Les packages R utilisés sont *spdep* et *spatialreg*.

```{r charger les packages,message=FALSE,warning=FALSE}
require(spatialreg)
require(spdep)
library(sp)
require(ggplot2)
require(tidyverse)
require(colorRamps)
require(GGally)
```


## Représentation de la carte et des strates

```{r charger les donnees}
# Lecture des donnees
#--------------------
donnees = read.csv(file = "StLaurent.csv",sep=";")
donnees$BH = as.factor(donnees$BH)
coords = cbind(donnees$longitude,donnees$latitude)
bornes = read.table(file = "bornes.txt")
bornes = as.matrix(bornes)
```

Utiliser la fonction *traceStrates* pour visualiser les strates.

```{r trace carte, echo=FALSE,message=FALSE,warning=FALSE}
source("tracePoly.R")
coordStr = donnees[,1:3]
traceStrates(coordStr,titre=?,couleur = ?)
```

## Systèmes de voisinage
Constituer plusieurs systèmes de voisinage (fonctions *tri2nb*, *knearneigh* et *knn2nb*, *dnearneigh*, *poly2nb*}. Les tracer.   
Etablir plusieurs matrices de poids (fonctions *nb2listw* et  *nb2mat*).

```{r Voisinages, message=FALSE,warning=FALSE}      
strate = as.character(donnees[,1])
voisinage1 <- tri2nb(?,?) # par triangulation
titre = ?
plotVois(?,?,titre=titre,coulcoor=?,coularete=?)

ppv <- knearneigh(?, k=?,longlat = ?)
voisinage2 = knn2nb(?)
titre = ?
plotVois(?,?,titre=titre,coulcoor=?,coularete=?)

voisinage3 <- dnearneigh(?, d1=?, d2=?,longlat = ?)
titre = ?
plotVois(?,?,titre=titre,coulcoor=?,coularete=?)

voisinage4 = poly2nb(StratePoly)
titre = ?
plotVois(?,?,titre=titre,coulcoor=?,coularete=?)

# matrice de voisinage
#---------------------
# B is the basic binary coding, 
# W is row standardised (sums over all links to n), 
# C is globally standardised (sums over all links to n), 
# U is equal to C divided by the number of neighbours (sums over all links to unity), while 
# S is the variance-stabilizing coding scheme proposed by Tiefelsdorf et al. 1999, p. 167-168 (sums over all links to n).
voisinage = ?
poids.vois <- nb2listw(voisinage,style=?)
mat.vois   <- nb2mat(voisinage,style =?)
poids.vois.sym = listw2U(poids.vois)  # pour symetriser W (pb avec plus proches voisins)
```
## Autocorr\'elation

### Données binaires
Représenter la variable $BH$ sur la carte. Tester l'autocorrélation spatiale de la variable $BH$ (fonctions *joincount.test*, *joincount.mc*). Comment dépend le test des poids de voisinage?

```{r donnees binaires, echo=FALSE,message=FALSE,warning=FALSE}  
titre = ?
traceStrates(coordStr,titre=titre,valeurs=?,couleur=?)

print(joincount.mc(?,poids.vois.sym,nsim=?))
print(joincount.test(?,poids.vois.sym))
```
          
### Indice de Moran et de Geary
Représenter la variable $totconsum$ sur la carte.  Tester l'autocorrélation spatiale de la variable $totconsum$ \`a l'aide de l'indice de Moran
(*moran.test*, *moran.mc*) avec ou sans randomisation.   
Calculer le corrélogramme  *sp.correlogram*).   
Tester l'autocorrélation spatiale de la variable $totconsum$ à l'aide de l'indice de Geary (fonctions *geary.test*, *geary.mc*).   
Comparer à l'indice de Moran.

```{r donnees continues, echo=FALSE,message=FALSE,warning=FALSE}
titre = ?
traceStrates(coordStr,valeurs=?,titre=titre,couleur=?)

print(moran(?,poids.vois,length(?),Szero(poids.vois)))
print(moran.mc(?,?,nsim=?))
print(moran.test(?,?))
print(moran.test(?,?,randomisation=F))
print(sp.correlogram(voisinage,donnees$totconsum,order=5,method="I",zero.policy=T))
plot(sp.correlogram(?,?,order=?,method="I",zero.policy=T))
print(geary(?,?,length(?),length(?)-1,Szero(poids.vois)))
print(geary.mc(?,?,nsim=?))
print(geary.test(?,?))
print(geary.test(?,?,randomisation=F))
```
          
## Représentation des covariables
Représenter les cartes de profondeur et température. 
```{r covariables,message=FALSE,warning=FALSE}
titre = paste("Profondeur")
traceStrates(coordStr,valeurs=?,titre=titre,couleur=?)
titre = paste("Temperature")
traceStrates(coordStr,valeurs=?,titre=titre,couleur=?)
```	
## Régression spatiale
```{r correlation, echo=FALSE,message=FALSE,warning=FALSE}
ggpairs(donnees,columns = ?)
```

### Modèle linéaire
Faire la régression linéaire de $totconsum$ sur $depth$ et $temperature$. Tester l'autocorrélation spatiale des résidus (fonction * lm.morantest*).   
Représenter la carte des résidus.

```{r modele lineaire, echo=FALSE,message=FALSE,warning=FALSE}
ggpairs(donnees,columns = ?)

totcons.lm <- lm(?) 
summary(totcons.lm)
anova(totcons.lm)

lm.morantest(totcons.lm,poids.vois)

res0 <- residuals(totcons.lm)
moran.test(?,?) 
titre = ?
traceStrates(coordStr,valeurs=?,titre=titre,couleur=?)
```

### Modèles à erreur et retard SAR

Faire la régression linéaire  avec une erreur SAR  (*errorsarlm* ). 
$$
   Y =  X \beta + e \qquad e = \rho W e + \varepsilon
$$
Tester l'autocorrélation spatiale des résidus. Représenter la carte des résidus.
```{r}
totcons.errorsarlm <- errorsarlm(? ,data=?,poids.vois) 
```

Faire la régression linéaire  avec retard SAR (fonction *lagsarlm*).  
$$
   Y = \rho W Y + X \beta + \varepsilon
$$
Tester l'autocorrélation spatiale des résidus. Représenter la carte des résidus.

```{r}
totcons.lagsarlm <- lagsarlm(? ,data=?,poids.vois) 
```

Faire la régression linéaire mixte  avec retard et erreur SAR (fonction  *lagsarlm, type='mixed'*).  
$$
   Y = \rho W Y + X \beta + \qquad e = \rho W e + \varepsilon
$$
Tester l'autocorrélation spatiale des résidus. Représenter la carte des résidus.

```{r}
totcons.mixed <- lagsarlm(? ,data=?,poids.vois,type="mixed") 
```
Même modèle, mais avec estimation par maximum de vraisemblance

```{r}
totcons.sacsar = sacsarlm(?, poids.vois, data = ?)
```

### Comparaison des modèles

Comparer les modèles à l'aide des fonctions *lm.LMtests, LR.sarlm, anova, AIC*.  
Interpréter les coefficients obtenus dans chaque cas. Le système de voisinage a-t-il une influence?

```{r SAR, message=FALSE,warning=FALSE}
lm.LMtests(?)
LR.Sarlm(?)
anova(?)
AIC(?)
```

